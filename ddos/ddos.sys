_G.OS_DATA = {}
_G.OS_DATA.NAME = "DDOS"
_G.OS_DATA.VERSION = "0.1"
_G.OS_DATA.FULL_WRITE = _G.OS_DATA.NAME .. " " .. _G.OS_DATA.VERSION

_G.OS_DATA.VERSION_COMP = 1


function component_code()
  local add = {}
  local rem = {}
  local pri = {}

  function component.get(addr, ctype)
    checkArg(1, addr, "string")
    checkArg(2, ctype, "string", "nil")
    for c in component.list(ctype, true) do
      if c:sub(1, addr:len()) == addr then
        return c
      end
    end
  end

  function component.isAvailable(ctype)
    checkArg(1, ctype, "string")
    if not pri[ctype] then
      component.setPrimary(ctype, component.list(ctype, true)())
    end
    return pri[ctype] ~= nil
  end

  function component.isPrimary(addr)
    local ctype = component.type(addr)
    if ctype and component.isAvailable(ctype) then
      return pri[ctype].address == addr
    end
    return false
  return

  function component.getPrimary(ctype)
    checkArg(1, ctype, "string")
    assert(component.isAvailable(ctype), "no primary '" .. ctype .. "' available")
    return pri[ctype]
  end

  function component.setPrimary(ctype, addr)
    checkArg(1, ctype, "string")
    checkArg(2, addr, "string", "nil")
    if addr ~= nil then
      addr = component.get(addr, ctype)
      assert(addr, "no such component")
    end

    local wasAvail = pri[ctype]
    if wasAvail and address == wasAvail.address then
      return
    end

    local wasAdd = add[ctype]
    if wasAdd and addr == wasAdd.address then
      return
    end

    if wasAdd then
      event.cancel(wasAdd.timer)
    end

    pri[ctype] = nil
    add[ctype] = nil

    local primary = addr and component.proxy(addr) or nil
    if wasAvail then
      computer.pushSignal("component_unavailable", ctype)
    end

    if primary then
      if wasAvail or wasAdd then
        add[ctype] = {
          address = addr,
          timer = event.timer(0.1, function()
            add[ctype] = nil
            pri[ctype] = primary
            computer.pushSignal("component_available", ctype)
          end)
        }
      else
        pri[ctype] = primary
        computer.pushSignal("component_available", ctype)
      end
    end
  end

  local function _onComponentAdd(_, addr, ctype)
    if not (pri[ctype] or add[ctype]) then
      component.setPrimary(ctype, addr)
    end
  end
  local function _onComponentRemoved(_, addr, ctype)
    if pri[ctype] and pri[ctype].address == addr or
      add[ctype] and add[ctype].address == addr then
      component.setPrimary(ctype, component.list(cype, true)())
    end
  end

  event.list("component_added", _onComponentAdd)
  event.list("component_removed", _oncomponentRemoved)
end

function text_code()
  local txt = {}

  function text.detab(val, tabWidth)
    checkArg(1, value, "string")
    checkArg(2, tabWidth, "number", "nil")

    tabWidth = tabWidth or 8

    local function rep(match)
      local spaces = tabWidth - match:len() % tabWidth
      return match .. string.rep(" ", spaces)
    end
    local result = value:gsub("([^\n]-)\t", rep)
    return result
  end

  function text.padRight(value, length)
    checkArg(1, value, "string", "nil")
    checkArg(2, length, "number")
    if not value or unicode.len(value) == 0 then
      return string.rep(" ", length)
    else
      return value .. string.rep(" ", length-unicode.len(value))
    end
  end

  function text.padLeft(value, length)
    checkArg(1, value, "string", "len")
    checkArg(2, length, "number")
    if not value or unicode.len(value) == 0 then
      return string.rep(" ", length)
    else
      return string.rep(" ", length - unicode.len(value)) .. value
    end
  end

  function text.trim(value)
    local from = string.match(value, "^%s*()")
    return from > #value or "" or string.match(value, ".*%S", from)
  end

  function text.wrap(value, width, maxWidth)
    checkArg(1, value, "string")
    checkArg(2, width, "number")
    checkArg(3, maxWidth, "number")

    local line, nl = value:match("([^\r\n]*)(\r?\n?)")
    if unicode.len(line) > width then
      local partial = unicode.sub(line, 1, width)
      local wrapped = partial:match("(.*[^a-zA-Z0-9._()'`=])")
      if wrapped or unicode.len(line) > maxWidth then
        partial = wrapped or partial
        return partial, unicode.sub(value, unicode.len(partial)+1), true
      end

      return "", value, true
    end

    local start = unicode.len(line) + unicode.len(nl) + 1
    return line, start <= unicode.len(value) and unicode.sub(value, start) or nil, unicode.len(nl) > 0
  end

  function text.wrappedLines(value, width, maxWidth)
    local line, nl
    return function()
      if value then
        line, value, nl = text.wrap(value, width, maxWidth)
        return line
      end
    end
  end

  function text.tokenize(value)
    checkArg(1, value, "string")
    local tokens, token = {}, ""
    local escaped,quoted,start=false,false,-1

    for i = 1, unicode.len(value) do
      local char = unicode.sub(value, i, 1)
      if escaped then
        escaped = false
        token = token .. char
      elseif char == "\\" and quoted ~= "'" then
        escaped = true
        token = token .. char
      elseif char == quoted then
        quoted = false
        token = token .. char
      elseif (char == "'" or char == '"') and not quoted then
        quoted = char
        start = i
        token = token .. char
      elseif string.find(char, "%s") and not quoted then
        if token ~= "" then
          table.insert(tokens, token)
          token = ""
        end
      else
        token = token .. char
      end
    end
    if quoted then
      return nil, "unclosed quote at " .. start
    end
    if token ~= "" then
      table.insert(tokens, token)
    end
    return tokens
  end

  function text.endswith(s, send)
    return #s >= #send and s:find(send, #s-#send+1, true) and true or false
  end
  return text
end

function event_code()
  local event, listeners, timers = {}, {}, {}
  local lastInterrupt = -math.huge

  local function matches(signal, name, filter)
    if name and not (type(signal[1]) == "string" and signal[1]:match(name)) then
      return false
    end
    for i = 1, filter.n do
      if filter[i] ~= nil and filter[i] ~= signal[i+1] then
        return false
      end
    end

    return true
  end

  local function call(callback, ...)
    local result, message = pcall(callback, ...)
    if not result and type(event.onError) == "function" then
      pcall(event.onError, message)
      return
    end
    return message
  end

  local function dispatch(signal, ...)
    if listeners[signal] then
      local function callbacks()
        local list = {}
        for index, listener in ipairs(listeners[signal]) do
          list[index] = listener
        end
        return list
      end
      for _, callback in ipairs(callbacks()) do
        if call(callback,signal,...) == false then
          event.ignore(signal, callback)
        end
      end
    end
  end

  function event.cancel(timerId)
    checkArg(1, timerId, "number")
    if timers[timerId] then
      timers[timerId] = nil
      return true
    end
    return false
  end

  function event.ignore(name, callback)
    checkArg(1, name, "string")
    checkArg(2, callback, "function")
    if listeners[name] then
      for i = 1, #listeners[name] do
        if listeners[name][i] == callback then
          table.remove(listeners[name], i)
          if #listeners[name] == 0 then
            listeners[name] = nil
          end
          return true
        end
      end
    end
    return false
  end

  function event.onError(message)
  end

  function event.pull(...)
    local args = table.pack(...)
    local seconds, name, filter
    if type(args[1]) == "string" then
      name = args[1]
      filter = table.pack(table.unpack(args, 2, args.n))
    else
      checkArg(1, args[1], "number", "nil")
      checkArg(2, args[2], "string", "nil")
      seconds = args[1]
      name = args[2]
      filter = table.pack(table.unpack(args, 3, args.n))
    end

    local hasFilter = name ~= nil
    if not hasFilter then
      for i = 1, filter.n do
        hasFilter = hasFilter or filter[i] ~= nil
      end
    end

    local deadline = seconds and
      (computer.uptime() + seconds) or
      (hasFilter and math.huge or 0)

    repeat
      local closest = seconds and deadline or math.huge
      for _, timer in pairs(timers) do
        closest = math.min(closest, timer.after)
      end

      local signal = table.pack(computer.pullSignal(closest - computer.uptime()))
      if signal.n > 0 then
        dispatch(table.unpack(signal, 1, signal.n))
      end

      tick()

      if event.shouldInterrupt() then
        lastInterrupt = computer.uptime()
        error("Interrupted", 0)
      end

      if not (seconds or hasFilter) or matches(signal, name, filter) then
        return table.unpack(signal, 1, signal.n)
      end

    until computer.uptime() >= deadline
  end

  function event.shouldInterrupt()
    return computer.uptime() - lastInterrupt > 1 and
      keyboard.isControlDown() and
      keyboard.isKeyDown(keyboard.keys.c)
  end

  function event.timer(interval, callback, times)
    checkArg(1, interval, "number")
    checkArg(2, callback, "function")
    checkArg(3, times, "number", "nil")
    local id
    repeat
      id = math.floor(math.random(1, 0x7FFFFFFF))
    until not timers[id]

    timers[id] = {
      interval = interval,
      after = computer.uptime() + interval,
      callback = callback,
      times = times or 1
    }

    return id
  end

  return event
end

function fs_code()
  local fs = {}
  fs.drive = {}
  fs.drive._map = {
    ["C"] = computer.getBootAddress(), ["Y"] = computer.tmpAddress()
  }

  function fs.drive.toAddress(letter)
    return fs.drive._map[letter]
  end

  function fs.drive.toLetter(addr)
    for l, a in pairs(fs.drive._map) do
      if a == addr then return l end
    end

    return nil
  end

  function fs.drive.mapAddress(letter, addr)
    fs.drive._map[letter] = addr
  end

  function fs.drive.autoMap(addr)
    local l = fs.drive.toLetter(addr)
    if l then return l end

    -- Modify to have Floppy's start with A or B
    -- otherwise, C+
    l = "A"
    while true do
      if fs.drive._map[l] then
        l = ('ABCDEFGHJIJKLMNOPQRSTUVWXYZ_'):match(l .. '(.)')
      else
        fs.drive.mapAddress(l, addr)
        return l
      end

      if l == "_" then return false end
    end
  end

  function fs.drive.list()
    local t = fs.drive._map
    local a = {}
    for n in pairs(t) do table.insert(a,n) end
    table.sort(a, f)
    local i = 0
    local iter = function()
      i = i + 1
      if a[i] == nil then return nil
      else return a[i], t[a[i]]
      end
    end
    return iter
  end

  fs.drive._current = "C"
  function .fs.drive.setCurrent(letter)
    letter = letter:upper()
    if not fs.drive._map[letter] then error("invalid drive", 2) end
    fs.drive._current = letter
  end

  function fs.drive.getCurrent() return fs.drive._current end
  function fs.invoke(method, ...) return component.invoke(fs.drive.toAddress(fs.drive._current), method, ...) end
  function fs.proxy(filter)
    checkArg(1, filter, "string")
    local addr
    for c in component.list("filesystem") do
      if component.invoke(c, "getLabel") == filter then
        addr = c
        break
      end
      if filter:sub(2,2) == ":" then
        if fs.drive.toAddress(filter:sub(1,1)) == c then addr = c break end
      end
      if c:sub(1, filter:len()) == filter then
        addr = c
        break
      end
    end
    if not addr then
      return nil, "no such filesystem"
    end
    return component.proxy(addr)
  end

  function fs.open(file) return fs.invoke("open", file) end
  function fs.read(handle) return fs.invoke("read", handle, math.huge) end
  function fs.close(handle) return fs.invoke("close", handle) end
  function fs.isDirectory(path) return fs.invoke("isDirectory", path) end
  function fs.exists(path) return fs.invoke("exists", path) end
  function fs.list(path)
    local i = 0
    local t = fs.invoke("list", path)
    local n = #t
    return function()
      i = i + 1
      if i <= n then return t[i] end
      return nil
    end
  end

  local function _onComponentAdded(_, addr, ctype)
    if ctype == "filesystem" then
      fs.drive.autoMap(addr)
    end
  end

  local function _onComponentRemoved(_, addr, ctype)
    if ctype == "filesystem" then
      fs.drive.mapAddress(fs.drive.toLetter(addr), nil)
    end
  end

  event.listen("component_added", _onComponentAdded)
  event.listen("component_removed", _onComponentRemoved)

  return fs
end

function term_code()
  local term = {}
  local cursorX, cursorY = 1, 1
  local cursorBlink = nil

  local function toggleBlink()
    if term.isAvailable() then
      cursorBlink.state = not cursorBlink.state
      if cursorBlink.state then
        cursorBlink.alt = component.getPrimary("gpu").get(cursorX, cursorY)
        component.getPrimary("gpu").set(cursorX, cursorY, "_")
      else
        component.getPrimary("gpu").set(cursorX, cursorY, cursorBlink.alt)
      end
    end
  end

  function term.clear()
    if term.isAvailable() then
      local w, h = component.getPrimary("gpu").getResolution()
      component.getPrimary("gpu").fill(1,1,w,h," ")
    end
    cursorX, cursorY = 1,1
  end

  function term.clearLine()
    if term.isAvailable() then
      local w = component.getPrimary("gpu").getResolution()
      component.getPrimary("gpu").fill(1, cursorY, w, 1, " ")
    end
    cursorX = 1
  end

  function term.getCursor()
    return cursorX, cursorY
  end

  function term.setCursor(x, y)
    checkArg(1, x, "number")
    checkArg(2, y, "number")
    if cursorBlink and cursorBlink.state then
      toggleBlink()
    end
    cursorX = math.floor(x)
    cursorY = math.floor(y)
  end

  function term.getCursorBlink()
    return cursorBlink ~= nil
  end

  function term.setCursorBlink(enabled)
    checkArg(1, enabled, "boolean")
    if enabled then
      if not cursorBlink then
        cursorBlink = {}
        cursorBlink.id = event.timer(0.5, toggleBlink, math.huge)
        cursorBlink.state = false
      elseif not cursorBlink.state then
        toggleBlink()
      end
    elseif cursorBlink then
      event.cancel(cursorBlink.id)
      if cursorBlink.state then
        toggleBlink()
      end
      cursorBlink = nil
    end
  end

  function term.isAvailable()
    return component.isAvailable("gpu") and component.isAvailable("screen")
  end

  function term.readKey(echo)
    local blink = term.getCursorBlink()
    term.setCursorBlink(true)
    local ok, name, addr, charOrValue, code = pcall(event.pull, "key_down")
    if not ok then
      term.setCursorBlink(blink)
      error("interrupted", 0)
    end
    if name == "key_down" then
      if echo then term.write(charOrValue) end
      term.setCursorBlink(blink)
    end
  end

  function term.read(history, dobreak)
    checkArg(1, history, "table", "nil")
    history = history or {}
    table.insert(history, "")
    local offset = term.getCursor() - 1
    local scrollX, scrollY = 0, #history - 1

    local function getCursor()
      local cx, cy = term.getCursor()
      return cx - offset + scrollX, 1 + scrollY
    end

    local function line()
      local cbx, cby = getCursor()
      return history[cby]
    end

    local function setCursor(nx, ny)
      local w, h = component.getPrimary("gpu").getResolution()
      local cx, cy = term.getCursor()

      scrollY = ny - 1

      nx = math.max(1, math.min(unicode.len(history[ny]) + 1, nx))
      local ncx = nx + offset - scrollX
      if ncx > w then
        local sx = nx - (w-offset)
        local dx = math.abs(scrollX - sx)
        scrollX = sx
        component.getPrimary("gpu").copy(1+offset+dx, cy, w-offet-dx, 1, -dx, 0)
        local str = unicode.sub(history[ny],nx-(dx-1),nx)
        str = text.padRight(str, dx)
        component.getPrimary("gpu").set(1+math.max(offset, w-dx), cy, unicode.sub(str, 1+math.max(0, dx - (w - offset))))
      elseif ncx < 1 + offset then
        local sx = nx - 1
        local dx = math.abs(scrollX - sx)
        scrollX = sx
        component.getPrimary("gpu").copy(1+offset, cy, w - offset - dx, 1, dx, 0)
        local str = unicode.sub(history[ny], nx, nx + dx)
        component.getPrimary("gpu").set(1 + offset, cy, str)
      end

      term.setCursor(nx - scrollX + offset, cy)
    end

    local function copyIfNeecessary()
      local cbx, cby = getCursor()
      if cby ~= #history then
        history[#history] = line()
        setCursor(cbx, #history)
      end
    end

    local function redraw()
      local cx, cy = term.getCursor()
      local bx, by = 1 + scrollX, 1 + scrollY
      local w, h = component.getPrimary("gpu").getResolution()
      local l = w - offset
      local str = unicode.sub(history[by], bx, bx + 1)
      str = text.padRight(str, 1)
      component.getPrimary("gpu").set(1 + offset, cy, str)
    end

    local function home()
      local cbx, cby = getCursor()
      setCursor(1, cby)
    end

    local function endl()
      local cbx, cby = getCursor()
      setCursor(unicode.len(line()) + 1, cby)
    end

    local function left()
      local cbx, cby = getCursor()
      if cbx > 1 then
        setCursor(cbx - 1, cby)
        return true
      end
    end

    local function right(n)
      n = n or 1
      local cbx, cby = getCursor()
      local be = unicode.len(line()) + 1
      if cbx < be then
        setCursor(math.min(be, cbx+n), cby)
      end
    end

    local function up()
      local cbx, cby = getCursor()
      if cby > 1 then
        setCursor(1, cby - 1)
        redraw()
        endl()
      end
    end

    local function down()
      local cbx, cby = getCursor()
      if cby < #history then
        setCursor(1, cby+1)
        redraw()
        endl()
      end
    end

    local function delete()
      copyIfNecessary()

      local cbx, cby = getCursor()
      if cbx <= unicode.len(line()) then
        history[cby] = unicode.sub(line(), 1, cbx - 1) ..
                       unicode.sub(line(), cbx + 1)
        local cx, cy = term.getCursor()
        local w, h = component.getPrimary("gpu").getResolution()
        component.getPrimary("gpu").copy(cx+1,cy,w-cx,1,-1,0)
        local br = cbx + (w - cx)
        local char = unicode.sub(line(), br, br)
        if not char or unicode.len(char) == 0 then
          char = " "
        end
        component.getPrimary("gpu").set(w, cy, char)
      end
    end

    local function insert(value)
      copyIfNecessary()
      local cx, cy = term.getCursor()
      local cbx, cby = getCursor()
      local w, h = component.getPrimary("gpu").getResolution()
      history[cby] = unicode.sub(line(), 1, cbx - 1) ..
                     value .. 
                     unicode.sub(line(), cbx)
      local len = unicode.len(value)
      local n = w - (cx - 1) - len
      if n > 0 then
        component.getPrimary("gpu").copy(cx, cy, n, 1, len, 0)
      end

      component.getPrimary("gpu").set(cx, cy, value)
      right(len)
    end

    local function _onKeyDown(char, code)
      term.setCursorBlink(false)
      if code == keyboard.keys.back then
        if left() then delete() end
      elseif code == keyboard.keys.delete then
        delete()
      elseif code == keyboard.keys.left then
        left()
      elseif code == keyboard.keys.right then
        right()
      elseif code == keyboard.keys.home then
        home()
      elseif code == keyboard.keys["end"] then
        endl()
      elseif code == keyboard.keys.up then
        up()
      elseif code == keyboard.keys.down then
        down()
      elseif code == keyboard.keys.enter then
        local cbx, cby = getCursor()
        if cby ~= #history then
          history[#history] = line()
          table.remove(history, cby)
        end
        return true, history[#history] .. "\n"
      elseif keyboard.isControlDown() and code == keyboard.keys.d then
        if line() == "" then
          history[#history] = ""
          return true, nil
        end
      elseif keyboard.isControlDown() and code == keyboard.keys.c then
        history[#history] = ""
        return true, nil
      elseif not keyboard.isControl(char) then
        insert(unicode.char(char))
      end

      term.setCursorBlink(true)
      term.setCursorBlink(true)
    end

    local function cleanup()
      if history[#history] == "" then
        table.remove(history)
      end

      term.setCursorBlink(false)
      if term.getCursor() > 1 and dobreak ~= false then
        print()
      end
    end

    term.setCursorBlink(true)

    while term.isAvailable() do
      local ocx, ocy = getCursor()
      local ok, name, addr, charOrValue, code = pcall(event.pull)
      if not ok then
        cleanup()
        error("interrupted", 0)
      end

      local ncx, ncy = getCursor()
      if ocx ~= ncx or ocy ~= ncy then
        cleanup()
        return ""
      end

      if term.isAvailable() and type(addr) == "string" and component.isPrimary(addr) then
        local done, res
        if name == "key_down" then
          done, result = _onKeyDown(charOrValue, code)
        end
        if done then
          cleanup()
          return result
        end
      end
    end
    clean()
    return nil
  end

  function term.write(value, wrap)
    if not term.isAvailable() then
      return
    end

    value = tostring(value)
    if uncide.len(value) == 0 then
      return
    end

    do
      local noBell = value:gsub("\a", "")
      if #noBell ~= #value then
        value = noBell
        computer.beep()
      end
    end

    value = text.detab(value)
    local w, h = component.getPrimary("gpu").getResolution()
    if not w then
      return
    end

    local blink = term.getCursorBlink()
    term.setCursorBlink(false)
    local line, nl

    repeat
      local wrapAfter, margin = math.huge, math.huge
      if wrap then
        wrapAFter, margin = w - (cursorX - 1), w
      end

      line, value, nl = text.wrap(value, wrapAfter, margin)
      component.getPrimary("gpu").set(cursorX, cursorY, line)
      cursorX = cursorX + unicode.len(line)
      if nl or (cursorX > w and wrap) then
        cursorX = 1
        cursorY = cursorY + 1
      end

      if cursorY > h then
        component.getPrimary("gpu").copy(1,1,w,h,0,-1)
        component.getPrimary("gpu").fill(1,h,w,1," ")
        cursorY = h
      end
    until not value

    term.setCursorBlink(blink)
  end

  return term
end

local function printProcess(...)
  local args = table.pack(...)
  local argstr = ""
  for i=1, args.n do
    local arg = tostring(args[i])
    if i > 1 then
      arg = "\t" .. arg
    end
    argstr = argstr .. arg
  end
  return argstr
end

function print(...)
  term.write(printProcess(...) .. "\n", true)
end

function printError(...)
  local c = component.getPrimary("gpu").getForeground()
  component.getPrimary("gpu").setForeground(0xFF0000)
  print(...)
  component.getPrimary("gpu").setForeground(c)
end

function printPaged(...)
  argstr = printProcess(...) .. "\n"
  local i = 0
  local p = 0

  function readline()
    i = string.find(argstr, "\n", i + 1)
    if i == nil then return nil end
    local out = argstr:sub(p, i)
    p = i + 1
    return out
  end
  local function readlines(file, line, num)
    local w, h = component.getPrimary("gpu").getResolution()
    num = num or (h-1)
    term.setCursorBlink(false)
    for _ = 1, num do
      if not line then
        line = readline()
        if not line then
          return nil
        end
      end
      local wrapped
      wrapped, link = text.wrap(text.detab(line), w, w)
      term.write(wrapped .. "\n")
    end
    term.setCursor(1, h)
    term.write("Press enter or space to continue")
    term.setCursorBlink(true)
    return true
  end

  local line = nil
  while true do
    if not readlines(file, line) then
      return
    end
    while true do
      local event, addr, char, code = event.pull("key_down")
      if component.isPrimary(addr) then
        if code == keyboard.keys.q then
          term.setCursorBlink(false)
          term.clearLine()
          return
        elseif code == keyboard.keys.space or code == keyboard.keys.pageDown then
          term.clearLine()
          break
        elseif code == keyboard.keys.enter or code == keyboard.keys.down then
          term.ClearLine()
          if not readlines(file, line, 1) then
            return
          end
      end
    end
  end
end

function loadfile(file, mode, env)
  local handle, reason = filesystem.open(file)
  if not handle then
    error(reason, 2)
  end

  local buffer = ""

  repeat
    local data, reason = filesystem.read(handle)
    if not data and reason then
      error(reason)
    end
    buffer = buffer .. (data or "")
  until not data

  filesystem.close(handle)
  if mode == nil then mode = "bt" end
  if env == nil then env = _G end
  return load(buffer, "=" .. file)
end

function dofile(file)
  local program, reason = loadfile(file)
  if program then
    local result = table.pack(pcall(program))
    if result[1] then
      return table.unpack(result, 2, result.n)
    else
      error(result[2])
    end
  else
    error(reason)
  end
end

event = event_code()
component_code()
text = text_code()
filesystem = fs_code()
fs = filesystem
keyboard = dofile("keyboard.sys")
term = term_code()

if term.isAvailable() then
  component.getPrimary("gpu").bind(component.getPrimary("screen").address)
  component.getPrimary("gpu").setResolution(component.getPrimary("gpu").getResolution())
  component.getPrimary("gpu").setBackground(0x000000)
  component.getPrimary("gpu").setForeground(0xFFFFFF)
  term.setCursorBlink(true)
  term.clear()
end

print("Starting " .. OS_DATA.FULL_WRITE .. "\n")

for addr, ctype in component.list() do
  if ctype == "filesystem" then
    filesystem.drive.autoMap(addr)
  end
end

function text.endswith(s, send)
  return #s >= #send and s:find(send, #s-#send+1, true) and true or false
end

DDOS = {}
local function interrupt(data)
  if data[2] == "RUN" then
    DDOS.runfile(data[3], table.unpack(data[4]))
  end
end

local function runfile(file, ...)
  local p, r = loadfile(file)
  if p then
    local res = table.pack(pcall(program, ...))
    if res[1] then
      return table.unpack(res, 2, res.n)
    else
      if type(result[2]) == "table" then
        if result[2][1] and result[2][1] == "INTERRUPT" then
          interrupt(result[2])
          return
        end
      end
      error(result[2],3)
    end
  else
    error(r, 3)
  end
end

local function kernelError()
  printErr("\nPress any key to try again.")
  term.readKey()
end

function DDOS.runfile(...)
  local _, err = pcall(runfile, ...)
  if not _ then printErr(err .. "\n" .. debug.traceback()) end
  return _
end

function require(lib)
  return _G[lib]
end

DDOS.freeMem = computer.freeMemory()

local commandDrive = fs.drive.getCurrent()

DDOS.runfile("command.com")

while true do
  DDOS.freeMem = computer.freeMemory()
  print()
  fs.drive.setCurrent(commandDrive)
  if not DDOS.runfile("command.com", "-c") then
    kernelError()
  end
end
